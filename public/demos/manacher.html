<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manacher算法可视化演示</title>
    <style>
        :root {
            --cell-size: 40px;
            --primary-color: #3498db;
            --center-color: #f1c40f;
            --boundary-color: #e74c3c;
            --match-color: #2ecc71;
            --mismatch-color: #95a5a6;
            --bg-color: #f8f9fa;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--bg-color);
            margin: 0;
            padding: 20px;
        }

        h1 { color: #2c3e50; }

        /* 控制区域样式 */
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        input[type="text"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            width: 200px;
        }

        button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background-color: var(--primary-color);
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        button:hover { background-color: #2980b9; }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; }
        button.reset { background-color: #e67e22; }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
        }

        /* 可视化区域样式 */
        .visualization-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
            overflow-x: auto;
            max-width: 95vw;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .row {
            display: flex;
        }

        .row-label {
            width: 80px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 10px;
            font-weight: bold;
            color: #7f8c8d;
            flex-shrink: 0;
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            border: 1px solid #ecf0f1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            position: relative;
            flex-shrink: 0;
            transition: all 0.2s ease;
        }

        .cell small {
            font-size: 10px;
            position: absolute;
            top: 2px;
            left: 2px;
            color: #bdc3c7;
        }

        /* 状态颜色类 */
        .cell.char-cell { background-color: white; font-size: 18px; }
        .cell.p-cell { background-color: #fdfdfd; color: #555; }

        /* 高亮样式 */
        .highlight-center { border: 3px solid var(--primary-color) !important; z-index: 10; }
        .highlight-c { background-color: var(--center-color) !important; } /* 全局中心 C */
        .highlight-r { border-right: 3px solid var(--boundary-color) !important; } /* 右边界 R */
        
        .comparing { background-color: #d6eaf8 !important; }
        .matched { background-color: var(--match-color) !important; color: white !important; }
        .mismatched { background-color: var(--mismatch-color) !important; color: white !important; }

        /* 信息面板 */
        .info-panel {
            width: 100%;
            max-width: 800px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            border-left: 5px solid var(--primary-color);
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        .info-panel h3 { margin-top: 0; font-size: 16px; }
        .status-text { font-size: 18px; color: #333; margin-bottom: 10px; }
        .variable-monitor {
            font-family: monospace;
            background: #f1f1f1;
            padding: 10px;
            border-radius: 4px;
            display: flex;
            gap: 20px;
        }

        .legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            font-size: 12px;
            justify-content: center;
        }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .dot { width: 12px; height: 12px; border-radius: 50%; }

    </style>
</head>
<body>

    <h1>Manacher算法可视化</h1>

    <div class="controls">
        <input type="text" id="inputString" value="babad" placeholder="输入字符串">
        <button onclick="initVisualization()" class="reset">生成/重置</button>
        <div class="divider" style="width: 1px; height: 20px; background: #ddd;"></div>
        <button id="btnPrev" onclick="step(-1)" disabled>上一步</button>
        <button id="btnNext" onclick="step(1)" disabled>下一步</button>
        <button id="btnPlay" onclick="togglePlay()" disabled>自动播放</button>
        
        <div class="speed-control">
            <label for="speedRange">速度:</label>
            <input type="range" id="speedRange" min="100" max="1000" step="100" value="500">
        </div>
    </div>

    <div class="legend">
        <div class="legend-item"><div class="dot" style="border: 2px solid var(--primary-color)"></div> 当前中心 i</div>
        <div class="legend-item"><div class="dot" style="background: var(--center-color)"></div> 全局中心 C</div>
        <div class="legend-item"><div class="dot" style="background: var(--boundary-color)"></div> 右边界 R</div>
        <div class="legend-item"><div class="dot" style="background: var(--match-color)"></div> 匹配成功</div>
        <div class="legend-item"><div class="dot" style="background: var(--mismatch-color)"></div> 匹配失败</div>
    </div>

    <div class="visualization-container" id="visContainer">
        <!-- 动态生成的内容 -->
        <div style="padding: 20px; color: #aaa;">请输入字符串并点击"生成"开始</div>
    </div>

    <div class="info-panel">
        <div class="variable-monitor" id="varMonitor">
            C: - | R: - | i: - | i_mirror: -
        </div>
        <div class="status-text" id="statusText">准备就绪</div>
    </div>

<script>
    // 全局变量
    let frames = [];
    let currentFrameIndex = 0;
    let timer = null;
    let processedStr = "";
    
    // 初始化
    function initVisualization() {
        stopPlay();
        const input = document.getElementById('inputString').value;
        if (!input) return alert("请输入字符串");

        // 1. 预处理字符串
        // 为了方便演示，这里显示 ^ 和 $，但在实际逻辑中要注意索引对应
        let t = ['^'];
        for (let char of input) {
            t.push('#');
            t.push(char);
        }
        t.push('#');
        t.push('$');
        processedStr = t;

        // 2. 生成动画帧 (预计算所有步骤)
        frames = generateManacherFrames(processedStr);
        currentFrameIndex = 0;

        // 3. 构建DOM结构
        buildGrid(processedStr);

        // 4. 渲染第一帧
        renderFrame(0);
        updateControls();
    }

    // 核心逻辑：生成所有步骤的状态快照
    function generateManacherFrames(T) {
        let snapshots = [];
        let n = T.length;
        let P = new Array(n).fill(0);
        let C = 0, R = 0;

        // 辅助函数：添加快照
        function addSnapshot(type, i, c, r, pArr, extra = {}) {
            snapshots.push({
                type: type,
                i: i,
                C: c,
                R: r,
                P: [...pArr], // 浅拷贝数组
                ...extra
            });
        }

        addSnapshot('start', 0, 0, 0, P, {msg: "算法开始，初始化 C=0, R=0"});

        for (let i = 1; i < n - 1; i++) {
            let i_mirror = 2 * C - i;
            let msg = `当前中心 i=${i} ('${T[i]}')。`;
            
            addSnapshot('select_i', i, C, R, P, {msg: msg + " 选中中心点。", i_mirror: i_mirror});

            if (R > i) {
                let p_val = Math.min(R - i, P[i_mirror]);
                P[i] = p_val;
                addSnapshot('init_p', i, C, R, P, {
                    msg: `${msg} i 在 R 内。利用对称性初始化 P[i] = min(R-i, P[i_mirror]) = ${p_val}`,
                    i_mirror: i_mirror
                });
            } else {
                P[i] = 0;
                addSnapshot('init_p', i, C, R, P, {
                    msg: `${msg} i 在 R 外（或边界）。初始化 P[i] = 0`,
                    i_mirror: null
                });
            }

            // 中心扩展
            while (true) {
                let left = i - 1 - P[i];
                let right = i + 1 + P[i];

                // 边界检查（虽有哨兵，但为了演示清晰）
                if (left < 0 || right >= n) break;

                addSnapshot('compare', i, C, R, P, {
                    msg: `比较 T[${left}]('${T[left]}') 和 T[${right}]('${T[right]}')`,
                    left: left,
                    right: right
                });

                if (T[left] === T[right]) {
                    P[i]++;
                    addSnapshot('match', i, C, R, P, {
                        msg: "字符匹配！P[i] 增加。",
                        left: left,
                        right: right
                    });
                } else {
                    addSnapshot('mismatch', i, C, R, P, {
                        msg: "字符不匹配，停止扩展。",
                        left: left,
                        right: right
                    });
                    break;
                }
            }

            // 更新 C 和 R
            if (i + P[i] > R) {
                let oldC = C, oldR = R;
                C = i;
                R = i + P[i];
                addSnapshot('update_cr', i, C, R, P, {
                    msg: `回文右边界超过 R，更新 C=${C}, R=${R}`
                });
            }
        }
        
        addSnapshot('finish', 0, C, R, P, {msg: "算法完成！"});
        return snapshots;
    }

    // 构建HTML网格
    function buildGrid(chars) {
        const container = document.getElementById('visContainer');
        container.innerHTML = '';

        // 1. 索引行
        const idxRow = document.createElement('div');
        idxRow.className = 'row';
        idxRow.innerHTML = '<div class="row-label">索引</div>';
        chars.forEach((_, idx) => {
            idxRow.innerHTML += `<div class="cell" style="border:none; color:#999; font-size:12px;">${idx}</div>`;
        });
        container.appendChild(idxRow);

        // 2. 字符行
        const charRow = document.createElement('div');
        charRow.className = 'row';
        charRow.innerHTML = '<div class="row-label">T[i]</div>';
        chars.forEach((c, idx) => {
            const cell = document.createElement('div');
            cell.className = 'cell char-cell';
            cell.id = `char-${idx}`;
            cell.textContent = c;
            charRow.appendChild(cell);
        });
        container.appendChild(charRow);

        // 3. P数组行
        const pRow = document.createElement('div');
        pRow.className = 'row';
        pRow.innerHTML = '<div class="row-label">P[i]</div>';
        chars.forEach((_, idx) => {
            const cell = document.createElement('div');
            cell.className = 'cell p-cell';
            cell.id = `p-${idx}`;
            cell.textContent = '0';
            pRow.appendChild(cell);
        });
        container.appendChild(pRow);
    }

    // 渲染特定帧
    function renderFrame(index) {
        const state = frames[index];
        const n = processedStr.length;

        // 1. 重置所有样式
        document.querySelectorAll('.cell').forEach(el => {
            el.className = el.className.replace(/highlight-\w+|comparing|matched|mismatched/g, '').trim();
            // 保持基础类
            if(el.id.startsWith('char')) el.classList.add('char-cell');
            if(el.id.startsWith('p')) el.classList.add('p-cell');
        });

        // 2. 更新数值
        for (let j = 0; j < n; j++) {
            document.getElementById(`p-${j}`).textContent = state.P[j];
        }

        // 3. 应用高亮逻辑
        const i_el = document.getElementById(`char-${state.i}`);
        const p_i_el = document.getElementById(`p-${state.i}`);
        
        // 高亮当前中心 i (蓝色边框)
        if (state.type !== 'start' && state.type !== 'finish') {
            i_el.classList.add('highlight-center');
            p_i_el.classList.add('highlight-center');
        }

        // 高亮 C (背景黄)
        document.getElementById(`char-${state.C}`).classList.add('highlight-c');
        
        // 高亮 R (右边框红)
        // 注意：R 是右边界的索引，如果是虚指（^#a#...中），可能指向#
        if (state.R < n) {
            document.getElementById(`char-${state.R}`).classList.add('highlight-r');
        }

        // 比较/匹配动画
        if (state.type === 'compare') {
            document.getElementById(`char-${state.left}`).classList.add('comparing');
            document.getElementById(`char-${state.right}`).classList.add('comparing');
        } else if (state.type === 'match') {
            document.getElementById(`char-${state.left}`).classList.add('matched');
            document.getElementById(`char-${state.right}`).classList.add('matched');
        } else if (state.type === 'mismatch') {
            document.getElementById(`char-${state.left}`).classList.add('mismatched');
            document.getElementById(`char-${state.right}`).classList.add('mismatched');
        }

        // 4. 更新文本信息
        document.getElementById('statusText').textContent = state.msg;
        document.getElementById('varMonitor').innerHTML = `
            C: <span style="color:var(--center-color); font-weight:bold">${state.C}</span> | 
            R: <span style="color:var(--boundary-color); font-weight:bold">${state.R}</span> | 
            i: <span style="color:var(--primary-color); font-weight:bold">${state.i}</span> | 
            i_mirror: ${state.i_mirror !== undefined && state.i_mirror !== null ? state.i_mirror : '-'}
        `;

        // 滚动到当前活动区域
        if (state.i > 0) {
            const container = document.getElementById('visContainer');
            const target = document.getElementById(`char-${state.i}`);
            const offset = target.offsetLeft - container.offsetWidth / 2 + 20;
            container.scrollTo({ left: offset, behavior: 'smooth' });
        }
    }

    // 控制逻辑
    function step(direction) {
        let newIndex = currentFrameIndex + direction;
        if (newIndex >= 0 && newIndex < frames.length) {
            currentFrameIndex = newIndex;
            renderFrame(currentFrameIndex);
            updateControls();
        }
        if (newIndex >= frames.length - 1) {
            stopPlay();
        }
    }

    function togglePlay() {
        if (timer) {
            stopPlay();
        } else {
            startPlay();
        }
    }

    function startPlay() {
        const btn = document.getElementById('btnPlay');
        btn.textContent = "暂停";
        btn.style.backgroundColor = "#e74c3c";
        
        // 如果已经结束，重头开始
        if (currentFrameIndex === frames.length - 1) {
            currentFrameIndex = -1;
        }

        const speed = 1100 - document.getElementById('speedRange').value; // 反转：值越大越快(间隔越小)
        
        timer = setInterval(() => {
            if (currentFrameIndex < frames.length - 1) {
                step(1);
            } else {
                stopPlay();
            }
        }, speed);
    }

    function stopPlay() {
        clearInterval(timer);
        timer = null;
        const btn = document.getElementById('btnPlay');
        btn.textContent = "自动播放";
        btn.style.backgroundColor = ""; // 恢复默认
    }

    function updateControls() {
        document.getElementById('btnPrev').disabled = currentFrameIndex <= 0;
        document.getElementById('btnNext').disabled = currentFrameIndex >= frames.length - 1;
        document.getElementById('btnPlay').disabled = false;
    }
    
    // 初始化默认展示
    initVisualization();

</script>
</body>
</html>
